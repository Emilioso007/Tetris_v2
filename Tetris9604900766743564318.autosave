boolean newPiece;
PVector[] tetrimino; 

//the old blocks in level, not
//yet removed
boolean[][] garbage;

void setup(){
  size(320,640);
  
  frameRate(4);
  
  garbage = new boolean[10][20];
  
  newPiece = true;
}

void draw(){
  if (newPiece){
    tetrimino = createNewPiece();
    newPiece = false;
  }
  
  background(0);
  
  for (int i = 0; i < tetrimino.length; i++){
    PVector mino = tetrimino[i];
    rect(mino.x*32,mino.y*32, 32,32);
  }
  
  //draw garbage
  for (int y = 0; y < 20; y++){
    for (int x = 0; x < 10; x++){
      if (garbage[x][y]){
        rect(x*32,y*32, 32,32);
      }
    }
  }
  
  //mino hasn't hit the lower bounds
  //of the level or garbage
  for (int i = tetrimino.length-1; i >= 0; i--){
    PVector mino = tetrimino[i];
    if (mino.y < 20-1 && !garbage[(int)mino.x][(int)mino.y+1]){
      mino.add(new PVector(0,1));
    } else {
      garbage[(int)mino.x][(int)mino.y] = true;
      newPiece = true; 
    }
    
    if (newPiece){
      for (int j = 0; j < tetrimino.length; j++){
        garbage[(int)tetrimino[j].x][(int)tetrimino[j].y] = true;
      }
    }
    
    //stops the minos form falling down, after
    //garbage has been hit;
    if (newPiece){

        break;
      }
    }
  }
  
  //check for cleared lines
  for (int y = 0; y < 20; y++){
    boolean lineClear = true;
    for (int x = 0; x < 10; x++){
      if (!garbage[x][y]){
        lineClear = false;
        break;
      }
    }
    if (lineClear){
      for (int i = y; i > 0; i--){
        for (int x = 0; x < 10; x++){
          garbage[x][i] = garbage[x][i-1];
        }
      }
    }
  }
}

void keyPressed(){
  if (key == CODED){
    for (int i = 0; i < tetrimino.length; i++){
      PVector mino = tetrimino[i];
      switch (keyCode){
        case LEFT:
          if (mino.x > 0)
            mino.add(new PVector(-1,0));
          break;
        case RIGHT:
          if (mino.x < 10-1)
            mino.add(new PVector(1,0));
          break;
      }
    }
  }
}

PVector[] createNewPiece(){
  
  PVector[] pTetrimino;
  
  PVector[] newP = new PVector[4]; 
  
  pTetrimino = random(1) <= 0.5 ? OPiece : IPiece;
  
  newP[0] = pTetrimino[0].copy(); 
  newP[1] = pTetrimino[1].copy(); 
  newP[2] = pTetrimino[2].copy(); 
  newP[3] = pTetrimino[3].copy(); 
  
  return newP;
}
